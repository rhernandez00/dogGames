ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
VC:\u005cdogGames\u005cdata/0_untitled.py_2017_jun_22_1928
p8
sS'runtimeInfo'
p9
NsS'name'
p10
S'untitled.py'
p11
sS'dataNames'
p12
(lp13
S'mouse.x'
p14
aS'mouse.y'
p15
aS'mouse.leftButton'
p16
aS'mouse.midButton'
p17
aS'mouse.rightButton'
p18
asS'autoLog'
p19
I01
sS'extraInfo'
p20
(dp21
S'date'
p22
V2017_jun_22_1928
p23
sS'frameRate'
p24
cnumpy.core.multiarray
scalar
p25
(cnumpy
dtype
p26
(S'f8'
I0
I1
tRp27
(I3
S'<'
NNNI-1
I-1
I0
tbS'h\xcde\xbb\xa9*N@'
tRp28
sS'expName'
p29
g11
sS'session'
p30
V001
p31
sS'participant'
p32
V0
ssS'loopsUnfinished'
p33
(lp34
g1
(cpsychopy.data
TrialHandler
p35
g3
NtRp36
(dp37
S'origin'
p38
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.82.01), junio 22, 2017, at 19:28\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'untitled.py'\u000aexpInfo = {'participant':'', 'session':'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1600, 900), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "sample"\u000asampleClock = core.Clock()\u000apol1 = visual.ShapeStim(win=win, name='pol1',\u000a    vertices = [[-[0.5, 0.5][0]/2.0,-[0.5, 0.5][1]/2.0], [+[0.5, 0.5][0]/2.0,-[0.5, 0.5][1]/2.0], [0,[0.5, 0.5][1]/2.0]],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=[1,1,1], lineColorSpace='rgb',\u000a    fillColor=[1,1,1], fillColorSpace='rgb',\u000a    opacity=1,depth=0.0, \u000ainterpolate=True)\u000amouse = event.Mouse(win=win)\u000ax, y = [None, None]\u000a\u000a# Initialize components for Routine "options"\u000aoptionsClock = core.Clock()\u000apol2 = visual.Polygon(win=win, name='pol2',\u000a    edges = 5, size=[0.5, 0.5],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=[1,1,1], lineColorSpace='rgb',\u000a    fillColor=[1,1,1], fillColorSpace='rgb',\u000a    opacity=1,depth=0.0, \u000ainterpolate=True)\u000a\u000a# Initialize components for Routine "feedback"\u000afeedbackClock = core.Clock()\u000apolygon = visual.Rect(win=win, name='polygon',\u000a    width=[2, 2][0], height=[2, 2][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=[1,1,1], lineColorSpace='rgb',\u000a    fillColor=[1,1,1], fillColorSpace='rgb',\u000a    opacity=1,depth=0.0, \u000ainterpolate=True)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a# set up handler to look after randomisation of conditions etc\u000atrials = data.TrialHandler(nReps=5, method='random', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=[None],\u000a    seed=None, name='trials')\u000athisExp.addLoop(trials)  # add the loop to the experiment\u000athisTrial = trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTrial.rgb)\u000aif thisTrial != None:\u000a    for paramName in thisTrial.keys():\u000a        exec(paramName + '= thisTrial.' + paramName)\u000a\u000afor thisTrial in trials:\u000a    currentLoop = trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTrial.rgb)\u000a    if thisTrial != None:\u000a        for paramName in thisTrial.keys():\u000a            exec(paramName + '= thisTrial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "sample"-------\u000a    t = 0\u000a    sampleClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    # setup some python lists for storing info about the mouse\u000a    # keep track of which components have finished\u000a    sampleComponents = []\u000a    sampleComponents.append(pol1)\u000a    sampleComponents.append(mouse)\u000a    for thisComponent in sampleComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "sample"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = sampleClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *pol1* updates\u000a        if t >= 0.0 and pol1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pol1.tStart = t  # underestimates by a little under one frame\u000a            pol1.frameNStart = frameN  # exact frame index\u000a            pol1.setAutoDraw(True)\u000a        # *mouse* updates\u000a        if t >= 0.0 and mouse.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            mouse.tStart = t  # underestimates by a little under one frame\u000a            mouse.frameNStart = frameN  # exact frame index\u000a            mouse.status = STARTED\u000a            event.mouseButtons = [0, 0, 0]  # reset mouse buttons to be 'up'\u000a        if mouse.status == STARTED:  # only update if started and not stopped!\u000a            buttons = mouse.getPressed()\u000a            if sum(buttons) > 0:  # ie if any button is pressed\u000a                # abort routine on response\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in sampleComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "sample"-------\u000a    for thisComponent in sampleComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # store data for trials (TrialHandler)\u000a    x, y = mouse.getPos()\u000a    buttons = mouse.getPressed()\u000a    trials.addData('mouse.x', x)\u000a    trials.addData('mouse.y', y)\u000a    trials.addData('mouse.leftButton', buttons[0])\u000a    trials.addData('mouse.midButton', buttons[1])\u000a    trials.addData('mouse.rightButton', buttons[2])\u000a    # the Routine "sample" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    \u000a    #------Prepare to start Routine "options"-------\u000a    t = 0\u000a    optionsClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    optionsComponents = []\u000a    optionsComponents.append(pol2)\u000a    for thisComponent in optionsComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "options"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = optionsClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *pol2* updates\u000a        if t >= 0.0 and pol2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            pol2.tStart = t  # underestimates by a little under one frame\u000a            pol2.frameNStart = frameN  # exact frame index\u000a            pol2.setAutoDraw(True)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in optionsComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "options"-------\u000a    for thisComponent in optionsComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # the Routine "options" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    \u000a    #------Prepare to start Routine "feedback"-------\u000a    t = 0\u000a    feedbackClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    feedbackComponents = []\u000a    feedbackComponents.append(polygon)\u000a    for thisComponent in feedbackComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "feedback"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = feedbackClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *polygon* updates\u000a        if t >= 0.0 and polygon.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            polygon.tStart = t  # underestimates by a little under one frame\u000a            polygon.frameNStart = frameN  # exact frame index\u000a            polygon.setAutoDraw(True)\u000a        if polygon.status == STARTED and t >= (0.0 + (1.0-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            polygon.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in feedbackComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "feedback"-------\u000a    for thisComponent in feedbackComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    thisExp.nextEntry()\u000a    \u000a# completed 5 repeats of 'trials'\u000a\u000awin.close()\u000acore.quit()\u000a
p39
sS'thisTrial'
p40
NsS'_exp'
p41
I86431792
sg10
S'trials'
p42
sg6
S'C:\\dogGames\\matchToSampleB.py'
p43
sS'thisRepN'
p44
I0
sg19
I01
sg20
g21
sS'data'
p45
g1
(cpsychopy.data
DataHandler
p46
c__builtin__
dict
p47
(dp48
g18
cnumpy.ma.core
_mareconstruct
p49
(cnumpy.ma.core
MaskedArray
p50
cnumpy
ndarray
p51
(I0
tp52
S'b'
tRp53
(I1
(I1
I5
tg26
(S'f4'
I0
I1
tRp54
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x01\x01\x01\x01'
Ntbsg14
g49
(g50
g51
g52
S'b'
tRp55
(I1
(I1
I5
tg26
(S'O4'
I0
I1
tRp56
(I3
S'|'
NNNI-1
I-1
I63
tbI00
S'\xd0Y9\x04P\xa3&\x05\x10mF\x058iF\x05\xd0mF\x05'
S'\x00\x00\x00\x00\x00'
Ntbsg16
g49
(g50
g51
g52
S'b'
tRp57
(I1
(I1
I5
tg54
I00
S'\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x01\x01\x01\x01'
Ntbsg15
g49
(g50
g51
g52
S'b'
tRp58
(I1
(I1
I5
tg56
I00
S'\xc0Y9\x04\xc0bF\x05\xc8oF\x05\x18hF\x05\xb8jF\x05'
S'\x00\x00\x00\x00\x00'
NtbsS'ran'
p59
g49
(g50
g51
g52
S'b'
tRp60
(I1
(I1
I5
tg54
I00
S'\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x00'
NtbsS'order'
p61
g49
(g50
g51
g52
S'b'
tRp62
(I1
(I1
I5
tg54
I00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x01\x01\x01\x01'
Ntbsg17
g49
(g50
g51
g52
S'b'
tRp63
(I1
(I1
I5
tg54
I00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x01\x01\x01\x01'
NtbstRp64
(dp65
S'isNumeric'
p66
(dp67
g18
I01
sg59
I01
sg14
I00
sg15
I00
sg16
I01
sg61
I01
sg17
I01
ssg42
g36
sS'dataTypes'
p68
(lp69
g59
ag61
ag14
ag15
ag16
ag17
ag18
asS'dataShape'
p70
(lp71
I1
aI5
asbsS'method'
p72
S'random'
p73
sS'sequenceIndices'
p74
cnumpy.core.multiarray
_reconstruct
p75
(g51
(I0
tS'b'
tRp76
(I1
(I1
I5
tg26
(S'i4'
I0
I1
tRp77
(I3
S'<'
NNNI-1
I-1
I0
tbI01
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
tbsS'finished'
p78
I00
sS'nReps'
p79
I5
sS'nRemaining'
p80
I4
sS'trialList'
p81
(lp82
NasS'seed'
p83
NsS'thisIndex'
p84
g25
(g77
S'\x00\x00\x00\x00'
tRp85
sS'thisN'
p86
I0
sS'thisTrialN'
p87
I0
sS'nTotal'
p88
I5
sS'_warnUseOfNext'
p89
I01
sbasS'saveWideText'
p90
I01
sS'thisEntry'
p91
(dp92
g14
g25
(g27
S')\\\x8f\xc2\xf5(\x8c?'
tRp93
sg15
g25
(g27
S'\xb3\xc3\xd4\xe5\xf6\x07\xa9?'
tRp94
sg16
I1
sg18
I0
sg17
I0
ssS'version'
p95
S''
sS'_paramNamesSoFar'
p96
(lp97
sS'entries'
p98
(lp99
sS'loops'
p100
(lp101
g36
asS'savePickle'
p102
I00
sb.