ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
VC:\u005cdogGames\u005cdata/test_exp2_2017_mar_24_0944
p8
sS'runtimeInfo'
p9
NsS'name'
p10
S'exp2'
p11
sS'dataNames'
p12
(lp13
sS'autoLog'
p14
I01
sS'extraInfo'
p15
(dp16
S'date'
p17
V2017_mar_24_0944
p18
sS'frameRate'
p19
cnumpy.core.multiarray
scalar
p20
(cnumpy
dtype
p21
(S'f8'
I0
I1
tRp22
(I3
S'<'
NNNI-1
I-1
I0
tbS'7\xde\xcc!\x8e\xddM@'
tRp23
sS'expName'
p24
g11
sS'session'
p25
S'001'
p26
sS'participant'
p27
S'test'
p28
ssS'loopsUnfinished'
p29
(lp30
g1
(cpsychopy.data
TrialHandler
p31
g3
NtRp32
(dp33
S'origin'
p34
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.82.01), marzo 12, 2017, at 17:46\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000a#from psychopy import locale_setup, gui, visual, core, data, event, logging, sound\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000aimport serial\u000aimport serial.tools.list_ports\u000aimport time\u000a\u000anTrials = 50\u000a\u000a\u000a#vars for servo\u000anPelletsMax = 13\u000anTubes = 4\u000a\u000atube = 1\u000anPelletsGiven = 0\u000atubesCord = [106,83,58,36]\u000arotTube = tubesCord[0]\u000aoutCord = 132\u000aports = list(serial.tools.list_ports.comports())\u000a\u000a\u000a\u000afor p in ports:\u000a    if "CH340" in p[1]:\u000a        strTmp = str(p)\u000a        strTmp = strTmp[0:5]\u000a        strTmp = strTmp.replace('COM','')\u000a        nPort = 'com' + strTmp\u000a\u000a#data = serial.Serial(nPort,9600,timeout=1)   \u000adataArduino = serial.Serial('com8',9600,timeout=1)\u000a#time.sleep(1)\u000a#dataArduino.write(str(rotTube))\u000a\u000adef reward():\u000a    #global nPelletsGiven\u000a    #global rotTube\u000a    #global tube\u000a    dataArduino.write(str(rotTube))\u000a    #nPelletsGiven += 1\u000a    #if nPelletsGiven >= nPelletsMax:\u000a    #    nPelletsGiven = 1\u000a    #    tube += 1\u000a    #    if tube > 4:\u000a    #        tube = 1\u000a    #    rotTube = tubesCord[tube-1]\u000a    #print 'tubo: ' + str(rotTube)\u000a    #print 'pellets: ' + str(nPelletsGiven)\u000a    \u000a        \u000atime.sleep(2)    \u000adataArduino.write(str(rotTube))\u000a\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'exp2'  # from the Builder filename that created this script\u000aexpInfo = {'session': '001', 'participant': 'test'}\u000a#dlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000a#if dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(800, 480), fullscr=True, screen=0, allowGUI=True, allowStencil=False,\u000a    monitor='testMonitor', color=[-1,-1,-1], colorSpace='rgb',\u000a    blendMode='avg')\u000a\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000a# Initialize components for Routine "trial"\u000a\u000ayCorrectMin = -1\u000ayCorrectMax = 1\u000a\u000a\u000a\u000atrialClock = core.Clock()\u000aincorrectPol = visual.Rect(win=win, name='incorrectPol',\u000a    width=[0.1, 2][0], height=[1, 2][1],\u000a    ori=0, pos=[-0.5, 0],\u000a    lineWidth=1, lineColor=[1,1,1], lineColorSpace='rgb',\u000a    fillColor=[1,0,0], fillColorSpace='rgb',\u000a    opacity=1,depth=0.0, \u000ainterpolate=True)\u000averdaderoPol = visual.Rect(win=win, name='verdaderoPol',\u000a    width=[2, 2][0], height=[2, 2][1],\u000a    ori=0, pos=[0.5, 0],\u000a    lineWidth=1, lineColor=[1,1,1], lineColorSpace='rgb',\u000a    fillColor=[0,1,0], fillColorSpace='rgb',\u000a    opacity=1,depth=-1.0, \u000ainterpolate=True)\u000amouse = event.Mouse(win=win)\u000ax, y = [None, None]\u000a\u000a# Initialize components for Routine "correctFeed"\u000acorrectFeedClock = core.Clock()\u000arewardState = visual.Rect(\u000a    win=win, name='rewardState',\u000a    width=(2, 2)[0], height=(2, 2)[1],\u000a    ori=0, pos=(0, 0),\u000a    lineWidth=1, lineColor=[1,1,1], lineColorSpace='rgb',\u000a    fillColor=[0,0,1], fillColorSpace='rgb',\u000a    opacity=1, depth=0.0, interpolate=True)\u000a\u000a# Initialize components for Routine "intervalInter"\u000aintervalInterClock = core.Clock()\u000ainterTrialPol = visual.Rect(win=win, name='interTrialPol',\u000a    width=[2, 2][0], height=[2, 2][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=[-1,-1,-1], lineColorSpace='rgb',\u000a    fillColor=[-1,-1,-1], fillColorSpace='rgb',\u000a    opacity=1,depth=0.0, \u000ainterpolate=True)\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a# set up handler to look after randomisation of conditions etc\u000atrials = data.TrialHandler(nReps=nTrials, method='random', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=[None],\u000a    seed=None, name='trials')\u000athisExp.addLoop(trials)  # add the loop to the experiment\u000athisTrial = trials.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTrial.rgb)\u000aif thisTrial != None:\u000a    for paramName in thisTrial.keys():\u000a        exec(paramName + '= thisTrial.' + paramName)\u000a\u000afor thisTrial in trials:\u000a    side = randint(low=2,size=1)\u000a    if side == 0:\u000a        verdaderoPol.pos = [-0.5,0]\u000a        incorrectPol.pos = [-1,0]\u000a        xCorrectMin = -1\u000a        xCorrectMax = 1\u000a    else:\u000a        verdaderoPol.pos = [-0.5,0]\u000a        incorrectPol.pos = [-1,0]\u000a        xCorrectMin = -1\u000a        xCorrectMax = 1\u000a    \u000a    currentLoop = trials\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTrial.rgb)\u000a    if thisTrial != None:\u000a        for paramName in thisTrial.keys():\u000a            exec(paramName + '= thisTrial.' + paramName)\u000a    \u000a    #------Prepare to start Routine "trial"-------\u000a    t = 0\u000a    trialClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    # setup some python lists for storing info about the mouse\u000a    mouse.x = []\u000a    mouse.y = []\u000a    mouse.leftButton = []\u000a    mouse.midButton = []\u000a    mouse.rightButton = []\u000a    mouse.time = []\u000a    # keep track of which components have finished\u000a    trialComponents = []\u000a    trialComponents.append(incorrectPol)\u000a    trialComponents.append(verdaderoPol)\u000a    trialComponents.append(mouse)\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "trial"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = trialClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *incorrectPol* updates\u000a        if t >= 0.0 and incorrectPol.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            incorrectPol.tStart = t  # underestimates by a little under one frame\u000a            incorrectPol.frameNStart = frameN  # exact frame index\u000a            incorrectPol.setAutoDraw(True)\u000a        \u000a        # *verdaderoPol* updates\u000a        if t >= 0.0 and verdaderoPol.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            verdaderoPol.tStart = t  # underestimates by a little under one frame\u000a            verdaderoPol.frameNStart = frameN  # exact frame index\u000a            verdaderoPol.setAutoDraw(True)\u000a        # *mouse* updates\u000a        if t >= 0.0 and mouse.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            mouse.tStart = t  # underestimates by a little under one frame\u000a            mouse.frameNStart = frameN  # exact frame index\u000a            mouse.status = STARTED\u000a            event.mouseButtons = [0, 0, 0]  # reset mouse buttons to be 'up'\u000a        if mouse.status == STARTED:  # only update if started and not stopped!\u000a            buttons = mouse.getPressed()\u000a            if sum(buttons) > 0:  # ie if any button is pressed\u000a                x, y = mouse.getPos()\u000a                mouse.x.append(x)\u000a                mouse.y.append(y)\u000a                mouse.leftButton.append(buttons[0])\u000a                mouse.midButton.append(buttons[1])\u000a                mouse.rightButton.append(buttons[2])\u000a                mouse.time.append(trialClock.getTime())\u000a                # abort routine on response\u000a                continueRoutine = False\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in trialComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "trial"-------\u000a    for thisComponent in trialComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # store data for trials (TrialHandler)\u000a    trials.addData('mouse.x', mouse.x[0])\u000a    trials.addData('mouse.y', mouse.y[0])\u000a    trials.addData('mouse.leftButton', mouse.leftButton[0])\u000a    trials.addData('mouse.midButton', mouse.midButton[0])\u000a    trials.addData('mouse.rightButton', mouse.rightButton[0])\u000a    trials.addData('mouse.time', mouse.time[0])\u000a    # the Routine "trial" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    \u000a    if ((x < xCorrectMax) & (x > xCorrectMin)) & ((y < yCorrectMax) & (y > yCorrectMin)):\u000a        rewardState.fillColor = [0.,0.,1.]\u000a        reward()\u000a        rewardReset = 1\u000a        #time.sleep(2)\u000a        \u000a    else:\u000a        rewardState.fillColor = [0.8,0.,0.]\u000a        \u000a    # ------Prepare to start Routine "correctFeed"-------\u000a    t = 0\u000a    correctFeedClock.reset()  # clock\u000a    frameN = -1\u000a    continueRoutine = True\u000a    routineTimer.add(3.000000)\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    correctFeedComponents = [rewardState]\u000a    for thisComponent in correctFeedComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    # -------Start Routine "correctFeed"-------\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        #if (routineTimer.getTime() < 1.00000) and (rewardReset == 1):\u000a            \u000a        #    rewardReset = 0\u000a        # get current time\u000a        t = correctFeedClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *rewardState* updates\u000a        if t >= 0.0 and rewardState.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            rewardState.tStart = t\u000a            rewardState.frameNStart = frameN  # exact frame index\u000a            rewardState.setAutoDraw(True)\u000a        elif rewardState.status == STARTED and t >= (0.0 + 1.0):\u000a            rewardState.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in correctFeedComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    # -------Ending Routine "correctFeed"-------\u000a    for thisComponent in correctFeedComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)    \u000a    #reward set to 0\u000a    dataArduino.write(str(rotTube))\u000a    \u000a    #------Prepare to start Routine "intervalInter"-------\u000a    t = 0\u000a    intervalInterClock.reset()  # clock \u000a    frameN = -1\u000a    routineTimer.add(1.000000)\u000a    # update component parameters for each repeat\u000a    # keep track of which components have finished\u000a    intervalInterComponents = []\u000a    intervalInterComponents.append(interTrialPol)\u000a    for thisComponent in intervalInterComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a\u000a    #-------Start Routine "intervalInter"-------\u000a    continueRoutine = True\u000a    while continueRoutine and routineTimer.getTime() > 0:\u000a        # get current time\u000a        t = intervalInterClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *interTrialPol* updates\u000a        if t >= 0.0 and interTrialPol.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            interTrialPol.tStart = t  # underestimates by a little under one frame\u000a            interTrialPol.frameNStart = frameN  # exact frame index\u000a            interTrialPol.setAutoDraw(True)\u000a        if interTrialPol.status == STARTED and t >= (0.0 + (2-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            interTrialPol.setAutoDraw(False)\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in intervalInterComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a\u000a    #-------Ending Routine "intervalInter"-------\u000a    for thisComponent in intervalInterComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    thisExp.nextEntry()\u000a    \u000a    \u000a# completed X repeats of 'trials'\u000adataArduino.close()\u000awin.close()\u000acore.quit()\u000a
p35
sS'thisTrial'
p36
NsS'_exp'
p37
I159376112
sg10
S'trials'
p38
sg6
S'C:\\dogGames\\simpleTouch.py'
p39
sS'thisRepN'
p40
I0
sg14
I01
sg15
g16
sS'data'
p41
g1
(cpsychopy.data
DataHandler
p42
c__builtin__
dict
p43
(dp44
S'ran'
p45
cnumpy.ma.core
_mareconstruct
p46
(cnumpy.ma.core
MaskedArray
p47
cnumpy
ndarray
p48
(I0
tp49
S'b'
tRp50
(I1
(I1
I50
tg21
(S'f4'
I0
I1
tRp51
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbsS'order'
p52
g46
(g47
g48
g49
S'b'
tRp53
(I1
(I1
I50
tg51
I00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01'
NtbstRp54
(dp55
S'isNumeric'
p56
(dp57
g45
I01
sg52
I01
ssg38
g32
sS'dataTypes'
p58
(lp59
g45
ag52
asS'dataShape'
p60
(lp61
I1
aI50
asbsS'method'
p62
S'random'
p63
sS'sequenceIndices'
p64
cnumpy.core.multiarray
_reconstruct
p65
(g48
(I0
tS'b'
tRp66
(I1
(I1
I50
tg21
(S'i4'
I0
I1
tRp67
(I3
S'<'
NNNI-1
I-1
I0
tbI01
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
tbsS'finished'
p68
I00
sS'nReps'
p69
I50
sS'nRemaining'
p70
I49
sS'trialList'
p71
(lp72
NasS'seed'
p73
NsS'thisIndex'
p74
g20
(g67
S'\x00\x00\x00\x00'
tRp75
sS'thisN'
p76
I0
sS'thisTrialN'
p77
I0
sS'nTotal'
p78
I50
sS'_warnUseOfNext'
p79
I01
sbasS'saveWideText'
p80
I01
sS'thisEntry'
p81
(dp82
sS'version'
p83
S''
sS'_paramNamesSoFar'
p84
(lp85
sS'entries'
p86
(lp87
sS'loops'
p88
(lp89
g32
asS'savePickle'
p90
I00
sb.